Тестовое задание.

Необходимо создать библиотечный класс для сериализации асинхронных процессов.

ЗАДАЧА.

Предположим, что имеется набор функций, которые выполняют некоторую асинхронную работу:
загрузку ресурсов с сервера, проигрывание анимаций или, например, диалог с пользователем.

У этих функций есть одно одно общее свойство - закончив свою деятельность, они вызывают переданный им
callback, обозначим его onEnd, в указанном контексте, обозначим его ctx.
Таким образом вызов любой такой функции будет выглядеть как:

    someFunction(ctx, onEnd, params ...) - где params - другие параметры необходимые функции.

Предположим, мы создадим массив функций такого рода, причем в этом массиве индекс каждой функции
будет соответствовать порядку ее вызова. Т.е. с помощью такого массива мы хотим обозначить
последовательность выполнения этих функций. При этом вызов последующей функции будет происходить
только после завершения предыдущей.

Каждая функция цепочки может принимать дополнительные параметры (обозначены выше params).
Обязательные параметры только ctx и onEnd - необходимые для продолжения цепочки.

Создайте класс, управляющий цепочкой вызовов таких функций.
Оформите этот класс в виде библиотечного класса с удобным интерфейсом.
Подумайте, какие возможности хотел бы видеть пользователь в подобном классе (пауза и рестарт цепочки, например).

Доп. задача:
Предположим, что мы хотим, чтобы некоторые функции из списка вызывались синхронно.
Цепочка вызовов продолжится, не дожидаясь окончания процесса начатого после таких вызовов. 
Возможно будет удобно, чтобы такие функции вызывались после окончания работы предыдущего шага цепочки.
Добавьте такой функционал в свой класс.

Представьте результат вашей работы в виде работающего примера, например, загрузки файлов.


Пример использования класса, который должен получиться:


  var chain = new ProcChain();   // ProcChain - это класс, который управляет цепочкой вызовов.


  function PlaySomeFragmentedAnimation(){

      chainList = [];

  	chainList.push(fragment1andParams); // заполняем массив функциями и их параметрами в каком либо виде.
      chainList.push(fragment2andParams);
      ...
      ...
      chainList.push(fragmentNandParams);

  	chainList.add(chainList);   // инициализировать цепочку

  	chain.start();             // запустить цепочку
  }

  function fragment1(ctx, onEnd, params){   // какой то фрагмент анимации

      ...
  	    //   play some animation using 'params'
     ...
     ...
     ...

     if(fragmentEnded){

       onEnd.call(ctx);

     };
  };

  function fragment2(ctx, onEnd, params){  // еще один фрагмент анимации

      ...
  	    //   play some animation using 'params'
     ...
     ...
     ...

     if(fragmentEnded){

       onEnd.call(ctx);

     };
  };

  ...

  ...
